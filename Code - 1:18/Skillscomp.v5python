{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n \n# Brain should be defined by default\nbrain=Brain()\n \n# Robot configuration code\ngps6 = Gps(Ports.PORT6, 0.00, -180.00, MM, 180)\nleft_motor_a = Motor(Ports.PORT1, GearSetting.RATIO_18_1, False)\nleft_motor_b = Motor(Ports.PORT3, GearSetting.RATIO_18_1, False)\nleft_drive_smart = MotorGroup(left_motor_a, left_motor_b)\nright_motor_a = Motor(Ports.PORT2, GearSetting.RATIO_18_1, True)\nright_motor_b = Motor(Ports.PORT4, GearSetting.RATIO_18_1, True)\nright_drive_smart = MotorGroup(right_motor_a, right_motor_b)\ndrivetrain_inertial = Inertial(Ports.PORT7)\ndrivetrain = SmartDrive(left_drive_smart, right_drive_smart, drivetrain_inertial, 319.19, 320, 40, MM, 1)\nflywheel = Motor(Ports.PORT5, GearSetting.RATIO_6_1, False)\ncontroller_1 = Controller(PRIMARY)\n \n \n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n \ndef calibrate_drivetrain():\n    # Calibrate the Drivetrain Inertial\n    sleep(200, MSEC)\n    brain.screen.print(\"Calibrating\")\n    brain.screen.next_row()\n    brain.screen.print(\"Inertial\")\n    drivetrain_inertial.calibrate()\n    while drivetrain_inertial.is_calibrating():\n        sleep(25, MSEC)\n    brain.screen.clear_screen()\n    brain.screen.set_cursor(1, 1)\n \n \ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n \n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n \n#endregion VEXcode Generated Robot Configuration\n \n# ------------------------------------------------------------------------------\n#\n#   Project:            Drive to Location (Unknown Starting Position)\n#   Description:        This example will show how to use a GPS Sensor to\n#                       navigate a V5 Moby Hero Bot to a specified position by\n#                       driving along the X-axis then the Y-axis\n#   Starting Position:  Any\n#   Configuration:      V5 Hero Bot (Drivetrain 2-motor, Inertial)\n#                       Motor Group on Port 2 and 9\n#                       Rotation on Port 4\n#                       GPS on Port 8\n#                       Distance on Port 12\n#                       Optical on Port 19\n#                       Distance on Port 20\n#                       Bumper on 3-Wire Port A\n#\n# ------------------------------------------------------------------------------\n \n# Library imports\nfrom vex import *\n \nreference_angle = 0\n \n# Define the front left motor\nfront_left_motor = Motor(Ports.PORT1, GearSetting.RATIO_18_1, False)\n# Define the front right motor\nfront_right_motor = Motor(Ports.PORT2, GearSetting.RATIO_18_1, True)\n# Define the back left motor\nback_left_motor = Motor(Ports.PORT3, GearSetting.RATIO_18_1, False)\n# Define the back right motor\nback_right_motor = Motor(Ports.PORT4, GearSetting.RATIO_18_1, True)\n# Define a motor group with the front two motors\nfront_motors = MotorGroup(front_left_motor, front_right_motor)\n# Define a motor group with the back two motors\nback_motors = MotorGroup(back_left_motor, back_right_motor)\n# Define a drivetrain with the front motor and back motor groups\ndrivetrain_strafe = DriveTrain(back_motors, front_motors, 319.19, 295, 40, MM, 1)\n#FLYWHEEL\nflywheel = Motor(Ports.PORT5, GearSetting.RATIO_6_1, False)\nflywheel.set_stopping(COAST)\n \ndef drive_to_position_y(y):\n    global reference_angle\n \n    # Reorient the robot before driving along the Y-axis\n    if gps6.y_position(MM) < y:\n        reference_angle = 0\n    else:\n        reference_angle = 180\n \n    # Using an absolute reference angle along with the GPS heading,\n    # we can turn the robot to face the correct direction\n    # before driving along the Y-axis\n    drivetrain.turn_for(RIGHT, (reference_angle - gps6.heading()), DEGREES)\n    drivetrain.drive(FORWARD)\n \n    # Keep driving until the GPS position for the Y-axis\n    # is within 20mm of the target Y position\n    while not (gps6.y_position(MM) - y > -20\n               and gps6.y_position(MM) - y < 20):\n        wait(5, MSEC)\n \n    # This will allow the drivetrain to stop in time,\n    # preventing the robot from overshooting the target\n    drivetrain.stop()\n \n \ndef drive_to_position_x(x):\n    global reference_angle\n \n    # Reorient the robot before driving along the X-axis\n    if gps6.x_position(MM) < x:\n        reference_angle = 90\n    else:\n        reference_angle = 270\n \n    # Using an absolute reference angle along with the GPS heading,\n    # we can turn the robot to face the correct direction\n    # before driving along the X-axis\n    drivetrain.turn_for(RIGHT, (reference_angle - gps6.heading()), DEGREES)\n    drivetrain.drive(FORWARD)\n \n    # Keep driving until the GPS position for the X-axis\n    # is within 20mm of the target X position\n    while not (gps6.x_position(MM) - x > -20\n               and gps6.x_position(MM) - x < 20):\n        wait(5, MSEC)\n \n    # This will allow the drivetrain to stop in time,\n    # preventing the robot from overshooting the target\n    drivetrain.stop()\n \n \ndef print_position():\n    # Print GPS position values to the V5 Brain\n    brain.screen.print(\"X: \", gps6.x_position(MM))\n    brain.screen.print(\"  Y: \", gps6.y_position(MM))\n    brain.screen.next_row()\n \n# Calibrate the Drivetrain for accurate turning\ncalibrate_drivetrain()\n \n# Calibrate the GPS Sensor\ngps6.calibrate()\nwhile gps6.is_calibrating():\n    sleep(25, MSEC)\n \ndrivetrain.set_turn_velocity(25, PERCENT)\n \n# Print the starting position of the robot\nprint_position()\n \n# Print the ending position of the robot\nbrain.screen.clear_screen()\nprint_position()\ndef autonomous():\n    #Calibrate flywheel\n    flywheel.set_stopping(COAST)\n    flywheel.set_velocity(100,PERCENT)\n    drivetrain.set_drive_velocity(55, PERCENT)\n    # drive reverse to pipe\n    drivetrain.drive_for(REVERSE, 280, MM)\n    # turn 45 degrees to the left\n    drivetrain.turn_for(LEFT, 45, DEGREES)\n    # drive reverse until touching pipe\n    #drivetrain.drive_for(REVERSE, 20, MM)\n    drivetrain.drive_for(REVERSE, 40, MM)\n    # spin flywheel for 30 seconds\n    flywheel.spin(FORWARD)\n    wait(50,SECONDS)\n    flywheel.stop()\n    # move forward 50 mm so it doesnt catch when it turns\n    drivetrain.drive_for(FORWARD, 70, MM)\n    # turn 45 degrees to the right\n    drivetrain.turn_for(RIGHT, 45, DEGREES)\n    # drive to other side of the field down alley\n    drivetrain.drive_for(FORWARD, 2470, MM)\n    #turn left\n    drivetrain.turn_for(LEFT, 90, DEGREES)\n    #pass the pole\n    drivetrain.drive_for(FORWARD, 770, MM)\n    #turn left to face the center\n    drivetrain.turn_for(LEFT, 90, DEGREES)\n    #move forward to the center pole\n    drivetrain.drive_for(FORWARD, 630, MM)\n    #turn right\n    drivetrain.turn_for(RIGHT, 90, DEGREES)\n    #Move to center\n    drivetrain.drive_for(FORWARD, 750, MM)\n    #turn left so back of robot is facing goal\n    drivetrain.turn_for(LEFT, 90, DEGREES)\n    #Ram tribsalls in\n    drivetrain.drive_for(REVERSE, 1100, MM)\n    #backout\n    drivetrain.drive_for(FORWARD, 800, MM)\n\ndef driver_control():\n    while True:\n        if controller_1.buttonY.pressing():\n            flywheel.spin(FORWARD, 100, PERCENT)\n        elif controller_1.buttonA.pressing():\n            flywheel.spin(FORWARD, 0, PERCENT)\n        elif controller_1.buttonRight.pressing():\n            flywheel.spin(REVERSE, 100, PERCENT)\n        # commenting out because it does not stop when button X pressed\n        #elif controller_1.buttonY.pressing():\n            #if controller_1.buttonX.pressing():\n                #drivetrain.stop()\n            #else:\n                # Move the robot backwards from the wall\n                #drivetrain.drive_for(REVERSE, 100, MM)\n                # Rotate the robot 90 degrees to the left\n                #drivetrain.turn_for(LEFT, 90, DEGREES)\n                # Move the robot to 1 inch from the wall\n                #drivetrain.drive_for(FORWARD, 100, MM)\n                # Rotate the robot 45 degrees to the left\n                #drivetrain.turn_for(LEFT, 45, DEGREES)\n                # Move the robot until it is past the bar\n                #drivetrain.drive_for(FORWARD, 300, MM)\n                \n        \n        else:\n \n            # Variable to set the speed for the front left motor based on controller joystick position\n            front_left_speed = controller_1.axis3.position() + controller_1.axis4.position() + controller_1.axis1.position()\n            # Variable to set the speed for the front right motor based on controller joystick position\n            front_right_speed = controller_1.axis3.position() - controller_1.axis4.position() - controller_1.axis1.position()\n            # Variable to set the speed for the back left motor based on controller joystick position\n            back_left_speed = controller_1.axis3.position() - controller_1.axis4.position() + controller_1.axis1.position()\n            # Variable to set the speed for the back right motor based on controller joystick position\n            back_right_speed = controller_1.axis3.position() + controller_1.axis4.position() - controller_1.axis1.position()\n \n            # Spin the front left motor based on the controller joystick position\n            front_left_motor.spin(FORWARD, front_left_speed, PERCENT)\n            # Spin the front right motor based on the controller joystick position\n            front_right_motor.spin(FORWARD, front_right_speed, PERCENT)\n            # Spin the back left motor based on the controller joystick position\n            back_left_motor.spin(FORWARD, back_left_speed, PERCENT)\n            # Spin the back right motor based on the controller joystick position\n            back_right_motor.spin(FORWARD, back_right_speed, PERCENT)\n \n    \n        # End autopilot code\n        \n# Define the competition to run auton and driver control during matches\ncompetition = Competition(driver_control, autonomous)\n ","textLanguage":"python","rconfig":[],"slot":0,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"3.0.4","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}